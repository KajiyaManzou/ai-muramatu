# 開発ステップ

企画書の段階ではBlazor Unlimited対話型WASMを採用する構想で検討したが、手法を確認後企画書を見直す。
プロジェクトに合った技術確認・機能確認のために3種類のプロトタイプ版を構築する。
機能の違いを比較し、プロジェクトに合う手法を選択する。
バックエンドWebAPIは共通とし、フロントエンドを作りわける。

## 進め方（バックエンド/フロントエンド分離検証）
- 方針: プロトタイプは「バックエンド」と「フロントエンド」に役割分担して並行/段階的に検証する。
- 手順:
  - Step A: バックエンド単体プロトタイプを先行（API仕様合意・認証・DB CRUD・CORSを固める）
  - Step B: フロントエンド（WASM / Auto）でAPI連携・認証フロー・UI/UX・PWAを検証
  - Step C: 結合検証（本番相当のRender環境でCORS/認証/ルーティング/キャッシュの整合性）
  - Step D: 比較結果を踏まえMVP構成を決定（採用/不採用の根拠を記録）

1. バックエンド: .NET WebAPI（RESTful）版
1. フロントエンド: Blazor Web App（レンダーモード: Interactive WebAssembly）版
1. フロントエンド: Blazor Web App（レンダーモード: Interactive Auto）版

動作検証、機能比較確認後、MVPに発展します

## 1. バックエンド: .NET WebAPI（RESTful）版

### ホスティング
- バックエンド: Render.com（コンテナサービス）
    - WebAPIサービス

### ソースコード管理
- ローカル: git
- リモート: GitHub

### 開発環境
- バックエンド
    - Docker: .NET
    - .NET c# WebAPI（RESTful）
    - データベース: Supabase（PostgreSQL）
    - 認証: Supabase Auth

#### データベース/接続情報
- 利用: Supabase（PostgreSQL）
- 環境変数: `DATABASE_URL`（Render提供の接続文字列を使用、SSL必須）
- シークレット管理: RenderのEnvironment / Secretで管理

### デプロイ
- スクリプト: GitHub Actions
    - RenderへのデプロイはGitHub連携のAuto Deploy（mainブランチ）
    - バックエンド（コンテナ）
        - Dockerfile: `backend/Dockerfile`
        - ポート: Renderの `PORT` をリッスン（`ASPNETCORE_URLS=http://0.0.0.0:$PORT`）
        - CORS: フロントの本番URLのみ許可

### 確認事項
- バックエンド
    - Supabase（PostgreSQL）のCRUDを操作するDapperを検証
    - Supabase Authのアクセストークン検証（JWKs/issuer/audience/exp）を実装・検証

### 開発・検証の分担（バックエンド）
- API: リソース設計、OpenAPI仕様、バリデーション、エラーモデル
- 認証: 外部IdPトークン検証（Supabase Auth）
- 権限: シンプルなロール/スコープ設計とミドルウェアでの保護
- DB: マイグレーション（DbUp）、Dapperリポジトリ、接続プーリング、タイムアウト
- 運用: CORS設定、ヘルスチェック、構成(ENV)とシークレット、ログ出力

### 認証/セキュリティ設計
- 認証方式: Supabase Auth（GoTrue）に統一。バックエンドは外部IdPトークンを検証のみ。
- 初期ユーザー: SupabaseダッシュボードまたはAdmin APIで作成/招待（Service Role Keyはバックエンドのみ保持）
- トークン検証: Supabase JWKsを定期更新でキャッシュし、issuer/audience/exp/nbfを検証
- 権限: クレーム（role 等）から最小権限でAPI保護。ロールはアプリ側で付与・解釈

### マイグレーション
- 方針: Dapper利用のため、アプリ内でDbUpを使ってSQLスクリプトを適用
- スクリプト配置: `backend/migrations`（例: `001_init.sql`, `002_add_table_x.sql`）
- 適用タイミング: バックエンド起動時に自動適用（本番は安全のため明示フラグで制御可）

### リポジトリ構成
- モノレポ: `backend/` と `frontend/`
- CIのパスフィルタ: `backend/**` 変更時のみバックエンドをビルド/デプロイ、`frontend/**` はフロントのみ

### 受け入れ条件（プロトタイプ完了基準）
- Supabase Authのユーザーでサインインしアクセストークンを取得できる
- 認証必須API（CRUD 1系統）がSupabaseトークンで保護されている
- DapperでDB CRUDが成功し、マイグレーションが適用される
- Renderにデプロイ済みで動作確認できる

## 2. Blazor Web App（レンダーモード: Interactive WebAssembly）版

### ホスティング
- フロントエンド: Render.com（静的サイト）
    - Interactive WebAssemblyのSPAルーティング対応として、リライト規則: `/* -> /index.html 200`

### ソースコード管理
- ローカル: git
- リモート: GitHub

### 開発環境
- フロントエンド
    - Docker: .NET　ローカル開発のみ
    - .NET Blazor Web App（レンダーモード: Interactive WebAssembly）

### デプロイ
- スクリプト: GitHub Actions
    - RenderへのデプロイはGitHub連携のAuto Deploy（mainブランチ）
    - フロント（静的）
        - Build: `dotnet publish -c Release`
        - PublishDir: `frontend/bin/Release/net8.0/publish/wwwroot`

### 確認事項
- フロントエンド
    - Interactive WebAssemblyの開発方法を検証
    - UI MudBlazorの機能・動作を検証
    - PWA機能・動作を検証
    - 認証フロー（ログイン→JWT保持→API呼出し→更新/期限切れ）のUX/エラー挙動を検証
    - 環境変数/設定（APIベースURL、ビルド時のBaseHref）の切替検証

### 開発・検証の分担（フロントエンド: WASM）
- API連携: HTTPクライアント、リトライ/再認証、CORS/プリフライト確認
- 認証: トークン保管方針（localStorage/SessionStorage/Memory）、XSS対策
- ルーティング: SPA直叩き時のリライト、認可ガード
- UI/UX: ローディング、エラートースト、フォームバリデーション
- PWA: キャッシュ戦略、更新検知、初回DLサイズ計測

### 認証/セキュリティ設計
- 認証方式: Supabase Auth（Email/Password等）。フロントでサインイン→access_tokenを保持
- トークン更新: refresh_tokenで自動更新を検証（期限/失効時の再ログイン導線）
- 保管方針: XSS対策のため可能な限りメモリ保持（必要に応じProtectedSessionStorage等を検討）
- API呼出し: `Authorization: Bearer <access_token>` を付与
- CORS: バックエンドでフロントURLを許可、`Authorization` ヘッダとプリフライト許可

### リポジトリ構成
- モノレポ: `backend/` と `frontend/`
- CIのパスフィルタ: `backend/**` 変更時のみバックエンドをビルド/デプロイ、`frontend/**` はフロントのみ

### 受け入れ条件（プロトタイプ完了基準）
- Supabase Authでサインインしaccess_token/refresh_tokenが取得・更新できる
- 認証必須API（CRUD 1系統）がSupabaseトークンで保護されている
- フロントからバックのAPI呼び出しがCORS許可で成功する
- Renderにデプロイ済みで動作確認できる
- SPAルーティング（直接URLアクセス）がリライト規則で動作する

## 3. Blazor Web App（レンダーモード: Interactive Auto）版

### ホスティング
- フロントエンド: Render.com（コンテナサービス）
    - Webサーバー + WASM配信

### ソースコード管理
- ローカル: git
- リモート: GitHub

### 開発環境
- フロントエンド
    - Docker: .NET
    - .NET Blazor Web App（レンダーモード: Interactive Auto）

### デプロイ
- スクリプト: GitHub Actions

### 確認事項
- フロントエンド
    - Interactive Autoの開発方法を検証
    - UI MudBlazorの機能・動作を検証
    - PWA機能・動作を検証
    - 初回ダウンロードの時間短縮を検証

### 開発・検証の分担（フロントエンド: Auto）
- ホスティング: コンテナでの配信、WebSockets/SignalR要件の確認
- API連携/認証: WASMと同様のフローをAutoモードでも確認
- ルーティング: サーバーレンダリング/ハイブリッド時の遷移・直リンク動作
- パフォーマンス: 初期表示、インタラクション遅延、AOT有無比較


### 認証/セキュリティ設計
- 認証方式: Supabase Authに統一（Autoモードでも同様）
- トークン更新: refreshフロー、サーバーレンダリング時のトークン受け渡しを確認
- セキュリティ: Cookie送信の要否/SameSite/HTTPSを検討（必要ならHttpOnlyクッキーに委譲）
- API呼出し: Bearer付与、未認証時のリダイレクト/エラーハンドリング
- CORS: バックエンド側でフロントの本番URLを許可

### リポジトリ構成
- モノレポ: `backend/` と `frontend/`
- CIのパスフィルタ: `backend/**` 変更時のみバックエンドをビルド/デプロイ、`frontend/**` はフロントのみ

### 受け入れ条件（プロトタイプ完了基準）
- Supabase Authでサインインしaccess_token/refresh_tokenが取得・更新できる
- 認証必須API（CRUD 1系統）がSupabaseトークンで保護されている
- DapperでDB CRUDが成功し、マイグレーションが適用される
- フロントからバックのAPI呼び出しがCORS許可で成功する
- フロント/バックともにRenderにデプロイ済みで動作確認できる
- SPAルーティング（直接URLアクセス）がリライト規則で動作する

---

## 想定される問題点と対策

- Supabase依存リスク: 認証基盤の可用性/レート制限/障害時影響
  - 対策: ステータス監視、バックオフ/リトライ、フェイルセーフ設計
- CORS/プリフライト失敗: AuthorizationヘッダやカスタムヘッダでOPTIONSが失敗する恐れ。
  - 対策: Render本番URLを正確にAllowし、`Access-Control-Allow-Headers` に必要ヘッダを明記、`Allow-Credentials` 要否を決定。
- SPA直リンクの404: Render静的サイトでリライト未設定だとルート以外が404になる。
  - 対策: `/* -> /index.html 200` を設定し、深いパスでの直アクセスを検証。
- PWAキャッシュの陳腐化: デプロイ後に古いアセットが残り最新UIが表示されない。
  - 対策: Service Workerのキャッシュバージョン付与/`skipWaiting`/`clientsClaim` 戦略、更新通知UIを実装。
- 初回DLサイズ/体感速度: WASMの初期ダウンロードが重く離脱を招く可能性。
  - 対策: AOT/Linker設定、アセンブリトリミング、遅延ロード、画像/フォントの最適化。
- GitHub ActionsとRender Auto Deployの二重デプロイ: GitHub連携とCIが競合し二重トリガーになる。
  - 対策: どちらかに統一。モノレポのパスフィルタで対象サービスのみをデプロイ。
- DBマイグレーションの安全性: 起動時自動適用は本番で危険。
  - 対策: 本番は明示フラグ/手動承認で実行。事前にバックアップ/リハーサルを実施。
- シークレット管理ミス: `SUPABASE_SERVICE_ROLE_KEY` や `DATABASE_URL` の誤設定/露出。
  - 対策: Service Role Keyはバックエンドのみ保存・最小権限化。Render Secret管理と起動時必須ENV検証を実装。
- トークン検証の時刻ずれ: サーバー時刻とクライアント時刻の差で`exp/nbf`エラー
  - 対策: NTP同期、許容スキュー（±数十秒）を検討
- APIベースURLの環境切替: ステージング/本番でエンドポイントが切り替わらない。
  - 対策: ビルド時設定と実行時設定の使い分け、環境別`appsettings`/静的設定を整理。
- Supabase接続のSSL要件: TLS必須/証明書検証で接続エラーが発生。
  - 対策: 接続文字列に`sslmode=require`/証明書設定を明記し本番/ローカル双方で検証。
- ログ/監視の不足: Renderのログのみでは事象の切り分けが困難。
  - 対策: 構造化ログ、相関ID、最低限のメトリクス/健全性チェックを用意。
